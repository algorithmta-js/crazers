# 프로그래머스 H-Index

조건은 두가지이다.

1. `n편 중 h번 이상 인용된 논문이 h편 이상` 
2. `나머지 논문이 h번 이하 인용되었는가` 

주어진 배열을 정렬하고 그 인덱스를 통해서 `몇개 이상의 논문이 있는지` 그리고 `몇개 이하의 논문이 있는지`를  판단할 수 있다.

## Solution

citations 배열을 내림차순으로 정렬한다.
정렬한 뒤 citations[0], 즉 가장 큰 수를 i로 설정하고 0까지 1씩 줄여가며 for loop을 순회한다.

각 loop 마다 하는 작업은 현재 i 값이 H-Index가 될 수 있는가를 판단하는 것이다.

---

citations = [25, 29, 6, 15]일 떄,
정렬 이후 [29, 25, 15, 6]이 되었을 것이다.

이제 29부터 loop를 돌며 각 i 값에 대해 H-Index의 가능성을 판단한다.

```javascript
// 내림차순 배열에서 target보다 크거나 같은 첫번째 요소의 인덱스를 반환. 없으면 -1 반환.
const findClosestLastIndex = (target) => {
  for (let [idx, val] of sortedCitations.entries()) {
      if (sortedCitations[idx + 1] !== val) {
          if (val === target) return idx;
          if (val < target) return idx - 1;        
      }
  }
  return -1;
}
```

1. 위의 함수를 이용해 각 숫자가 배열에서 어느 인덱스에 위치하는지를 알아낸다.
2. `위치값 + 1 >= i` 을 만족한다면 H-Index가 된다.
3. -1을 반환했을 경우 target 값이 배열 내의 최소값임을 뜻함. n보다 작다면 H-Index가 된다.


* 29는 어디에 위치하는가? -> 0번째. 즉, 29번 이상 인용된 논문은 1편이다. (본인 포함)
내림차순으로 정렬되었기에 자연스레 2번 조건은 만족한다. 하지만 1번 조건은 만족하지 못한다.

* 28은? -> 0번째와 1번째 사이. 즉, 28번 이상 인용된 논문은 1편이다. (H-Index X)

> 같은 맥락으로 26까지는 동일하다.

* 25는? -> 1번째. 즉, 25번 이상 인용된 논문은 2편이다. (H-Index X)

... 

* 6은? -> 3번째. 즉, 6번 이상 인용된 논문은 4편이다. (H-Index X)
* 5는? -> -1 반환. 최소값. 모든 논문이 5번 이상 인용되었음. 하지만 H-index가 n보다 클 수 없음. (H-Index X)
* 4는? -> -1 반환. 최소값. 모든 논문이 4번 이상 인용되었음. (H-Index O)

만족하는 가장 큰 값인 4가 답이 된다.