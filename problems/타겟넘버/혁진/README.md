# 프로그래머스 타겟 넘버

맨 앞에 있는 숫자도 1이 아니라 +1로 나타나는 점에서
연산자 배열을 만들면 되겠다고 생각함.

ex) +1+1-1+1+1 = 3 -> [1, 1, -1 ,1, 1]

target과 같은 답이 나오는 경우를 모두 찾아야 하기에 dfs를 활용해 완전탐색이 필요함.

-1일때와 +1일때 두가지에 대한 경우의 수를 따져줘야하기 때문에 
연산자 배열을 다음과 같이 사용하기로함.
* 처음엔 모든 값 0으로 초기화 
* 첫번째 재귀 호출 전 해당 위치의 값 +1 증가
* 두번째 재귀 호출 전 해당 위치의 값 +1 증가
* 연산자 배열의 값이 1일 때에는 +1로 간주, 2일 때에는 -1로 간주

재귀를 돌며 연산자 배열을 완성하고 마지막 위치에 도달하였을 때에는 값을 실제로 계산해보고 target과 같은지 비교함.

일치할 시 answer 값 증가.
모든 경우 탐색 후 answer 값 반환.

